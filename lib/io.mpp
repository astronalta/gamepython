/* 
 * An abstract handle for performing IO.  The handle can be a system file,.
 * standard input, standard output, or a socket.
 */ 
class IO::Handle;

int fd;  /* File descriptor on UNIX, HANDLE on Win32 */

public static native File STDIN;   /* Standard input file handle */
public static native File STDOUT;  /* Standard output file handle */
public static native File STDERR;  /* Standard error file handle */

/* Initializes the default file handles (stdin, stdout, stderr) */ 
@init() static native;

/* Creates a new file handle */
@init(int fd) private {
    self.fd = fd;  
}

/* Closes the file by calling 'close' if it hasn't already been called. */
@destroy() {
    close();
}

/* 
 * Reads up to up to 'n' bytes, where 'n' is the number of bytes to the end
 * of the pointer's valid range.  Returns the number of bytes read, or -1 if 
 * the read failed.  If the read fails, then the error flag will be set, and 
 * subsequent operations will fail until the error flags is checked.
 */
read(byte* buffer) native int;

/* 
 * Writes up to 'n' bytes, where 'n' is the number of bytes to the end of 
 * the pointer's valid range.  Returns the number of bytes written, or -1 if 
 * the write failed. 
 */
write(byte* buffer) native int;

/* 
 * Sets the offset of the open file handle to 'position' in the file.  On
 * underlying files that do not provide this operation, the operation is
 * ignored.  Returns 0 on success.
 */ 
seek(uint position) native int;

/* 
 * Returns information about the file associated with the open file handle.
 * See also IO::File::stat() for a similar function for unopened files.
 */
stat() native Stat;

/*
 * Closes the file handle, so that it no longer refers to any file and may be
 * reused.  If fd is the last copy of a particular file handle, then the 
 * associated resources are freed.
 */
close() native;


/* Example usage */
int main() {
    byte[] buffer = byte[](1024);
    byte* pointer = buffer;
    
    while (true && pointer) {
        int ret = IO::Handle::STDIN.read(pointer);
        if (ret <= 0) {
            println("Error!\n");
            return 1;
        }
        pointer += ret; 
    }
}

