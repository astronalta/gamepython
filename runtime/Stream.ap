# Copyright (c) 2010 Matt Fichman
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, APEXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import Buffer

Stream < Object {
    # This object is used to perform buffered character I/O on a file.  It can
    # be used to read from any device or input that the OS supports for the
    # underlying handle type, including sockets, files, pipes, etc.

    handle immutable Int
    # Opaque handle to the underlying file descriptor.

    read_buf private = Buffer(1024)
    write_buf private = Buffer(1024)

    @init(desc Int) {
        # Initializes a new stream, with 'handle' being an opaque pointer to
        # the OS file descriptor.  Note that if 'handle' is invalid, then
        # subsequent reads and writes will fail, and 'err' will be set.
        handle = desc
    }

    @destroy() {
        # Closes the file if it is still open.
        self.close()
    }

    read(buffer Buffer) native {
        # Reads data into 'buffer', and sets the 'count' field of buffer to the
        # number of bytes read.  This function will read up 'n' bytes, where
        # 'n' is equal to the 'length' field of 'buffer'.  If data is already
        # buffered to the internal buffer, that data will be copied into
        # 'buffer' first before an attempt to read more bytes from the OS is
        # made.
    }

    write(buffer Buffer) native {
        # Writes the data in 'buffer', and blocks until all the bytes are
        # written or the 'err' flag is set.  If data is already buffered in the
        # internal buffer, then 'flush()' will be called before writing
        # 'buffer' to the output stream.
    }

    get() native Char {
        # Returns the next character in the input stream. 
    }

    put(char Char) native {
        # Writes 'char' to the output buffer.  The character is not guaranteed
        # to be written to the output stream until 'flush()' is called.
    }
    
    scan(delim String) native String {
        # Reads all characters up to and including the first instance of
        # 'char'.  Returns a string containing the characters read.
    }

    print(string String) native {
        # Writes the characters in 'string' to the file.  The string is not
        # guaranteed to be written to the output stream until 'flush()' is
        # called.
    }

    scanln() String {
        # Reads in a line up to the ending '\n'
        ret self.scan('\n')
    }

    println(string String) {
        # Prints a string followed by '\n', and flushes the output.
        self.print(string)
        self.put('\n'c)
        self.flush()
    }
    
    peek() native Char {
        # Reads a character, but does not remove it from the internal buffer.
        # Call 'get' to read the next character and remove it.
    }

    flush() native {
        # Writes any characters in the internal output buffer to the output
        # stream.
    }
    
    close() native {
        # Calls 'flush()' then closes the file descriptor, so that no more
        # characters may be read or written.
    }
}

println(str String) native {
    # Prints 'str' to standard output, and flushes the output.
}

print(str String) native {
    # Prints 'str' to standard output.  Does not flush the output.
}
