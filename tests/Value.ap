# aptest exec on

Printer < Object {
    @destroy() {
        Io::println("destroy obj")
    }
}

Vector < Value {
    @init(x Int, y Int, z Int) {
        # Value type constructors take an extra 'self' pointer to the value
        # type on the stack/embedded in another type.  Likewise, the destructor
        # does not call free().
        #
        # Value types also have an additional hidden copy constructor that
        # increments refcounts for non-weak reference attributes.
        #
        # void Vector__init(Vector self); 
        # void Vector__copy(Vector self, Vector other);
        self.x = x
        self.y = y
        self.z = z
        self.print = Printer()
    }

    @destroy() {
        # Destructors for values types do not call free(); otherwise, they are
        # identical to reference type destructors.
        Io::println("destroy #{x} #{y} #{z}")
    }

    x Int
    y Int
    z Int
    print Printer

}

Complex < Value {
    real Int
    imag Int

    @init(real Int, imag Int) {
        self.real = real
        self.imag = imag
    }
}

returned() Vector {
    ret Vector(5, 5, 5)
}

parameter(param Vector) {
    vec = param
    vec.y = 6
    vec.z = 6
}

main() Int {
    # Check some simple stack allocations
    vec1 = Vector(1, 1, 1)
    Io::println("#{vec1.x} #{vec1.y} #{vec1.z}")
    vec2 = Vector(2, 2, 2)
    Io::println("#{vec2.x} #{vec2.y} #{vec2.z}") 

    # Now check allocating in a loop, to be sure we don't run out of mem
    i = 0 
    while i < 1000000 {
        compl = Complex(i, i) 
        ++i
    }
    compl = Complex(42, 42)

    # Anonymous stack alloc
    Vector(3, 3, 3).z = 30 # destroy 3 3 30

    # Assignment (copy)
    vec3 = vec1
    vec3.z = 10 

    # Assignment (copy, with destructor for prev value)
    vec3 = vec2 # destroy 1 1 10
    vec3.x = 4
    vec3.y = 4
    vec3.z = 4

    val = returned() # destroy 5 5 5 
    
    # Pass vector as a parameter
    parameter(vec1) # destroy 1 6 6 
    

    # destroy 4 4 4 (vec3)
    # destroy 2 2 2 (vec2)
    # destroy 1 1 1 (vec1)

    ret 0
}


