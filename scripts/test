#!/usr/bin/python

import optparse, os, subprocess, re, sys, glob, difflib

parser = optparse.OptionParser()
parser.add_option('-f', '--full', action='store_true', 
    help='Run all tests, including memcheck')
parser.add_option('-v', '--verbose', action='store_true',  
    help='Print test status')
(options, tests) = parser.parse_args()

os.chdir('tests')

fail_file = open('../build/test.fail', 'w')
total = 0
fail = False

if len(tests) == 0:
    # If no tests are passed as parameters, then glob on the test dir to run 
    # all the tests.
    tests = glob.glob('*.ap') + glob.glob('*.c') 
    tests += glob.glob('*.py') + glob.glob('*.cpp')

def check(test, expected, output):
    # Checks to make sure the output for the test matches the expected output.
    global fail
    expected = expected.replace('\r', '')
    output = output.replace('\r', '')

    if output != expected:
        fail_file.write(test+'\n')
        print(''.join(['-' for i in range(79)]))
        print('FAILED TEST: ' + test)
        print(''.join(['-' for i in range(79)]))
        expected_lines = expected.split('\n')
        output_lines = output.split('\n')
        print('\n'.join(difflib.unified_diff(
            expected_lines, 
            output_lines, 
            lineterm='',
            fromfile='Expected output',
            tofile='Actual output')))
        print(''.join(['-' for i in range(79)]))
        
        #print(''.join(['-' for i in range(70)])+' Expected')
        #print(''.join(['-' for i in range(70)])+' Expected')
        #print(expected)
        #print(''.join(['-' for i in range(72)])+' Output')
        #print(output)
        fail = True

def shell(command, check=False):
    # Runs 'command' and returns the result.  Sets the 'fail' flag if the 
    # command failed.
    proc = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE)
    ret = proc.stdout.read()
    if proc.wait() != 0 and check:
        return ret + '\nInvalid exit status' 
    else:
        return ret 

def apollo_test(test):
    # Run a compilation test.  Compile and Apollo source file, and potentially
    # run the resulting program.
    test = re.sub(r'.ap$', '', test)
    flags = ""
    run = False
    for line in open(test + '.ap'):
        if re.search(r'^# aptest print_ast on', line):
            flags += ' --dump-ast'
        elif re.search(r'^# aptest print_ir on', line):
            flags += ' --dump-ir'
        elif re.search(r'^# aptest exec on', line):
            flags += ' -e'
            run = True
        
    flags += ' -m --build-dir ../build/test --optimize -o'
    flags += ' ../bin/test/' + test.lower()
    command = '../bin/apollo ' + test + ' -i ../runtime -i ../lib ' + flags
    if options.full:
        valgrind = 'valgrind -q --leak-check=full --track-origins=yes'
        valgrind += ' --suppressions=../scripts/valgrind.supp'
        command = valgrind + ' ' + command
    expected = open(test + '.ap.out', 'rb').read() 
    if sys.platform == 'win32':
        command = command.replace('/', '\\')
    output = shell(command + ' 2>&1', run)
    check(test+'.ap', expected, output)

def python_test(test):
    # Run a Python test.  Useful for various msicellaneous tests that are not
    # easily expressed in C++.
    expected = open(test + '.out', 'r').read()
    output = shell('python ' + test + ' 2>&1')
    check(test, expected, output)

def native_test(test):
    # C/C++ tests.  Used primarily for unit tests and to test the runtime
    # library.
    expected = open(test + '.out', 'rb').read()
    exe = re.sub(r'.c$', '', test)
    output = ""
    if sys.platform == 'win32':
        command = 'cl ' + test + ' /Fe..\\build\\' + exe + ' /I:.. apollo.lib '
        command += '/link /NODEFAULTLIB:LIBCMT.lib /LIBPATH:..\\lib 2>&1'
        os.popen(command).read()
        output = shell('..\\build\\' + exe + ' 2>&1')
    else:
        command = 'gcc -g ' + test + ' -o ../build/' + exe + ' -L../lib '
        command += '-lApollo -lm -I .. 2>&1'
        os.popen(command).read()
        output += shell('../build/' + exe + ' 2>&1')
    check(test, expected, output)

def cpp_test(test):
    # C++ tests; used for compiler unit tests.
    expected = open(test + '.out', 'rb').read()
    exe = re.sub(r'.cpp$', '', test) 
    output = ""
    if sys.platform == 'win32':
        command = 'cl ' + test + ' /Fe..\\build\\' + exe + ' /I:../compiler '
        command += 'apolloc.lib '
        command += '/link /NODEFAULTLIB:LIBCMT.lib /LIBPATH:..\\lib 2>&1'
        os.popen(command).read()
        output = shell('..\\build\\' + exe + ' 2>&1')
    else:
        command = 'g++ -g ' + test + ' -o ../build/' + exe + ' -L../lib '
        command += '-lapolloc -lm -I ../compiler 2>&1'
        output += os.popen(command).read()
        output += shell('../build/' + exe + ' 2>&1')
    check(test, expected, output)

for test in tests:
    # Iterate through all the tests, and run the correct callback for each
    # test type.
    if re.search(r'.ap$', test):
        print(test)
        apollo_test(test)
        total += 1
    elif re.search(r'.py$', test):
        print(test)
        python_test(test)
        total += 1
    elif re.search(r'.c$', test) and not os.path.exists(test[:-2]+".ap"):
        print(test)
        native_test(test)
        total += 1
    elif re.search(r'.cpp$', test):
        print(test)
        cpp_test(test)
        total += 1

if fail:
    # Finally, check for errors.  If there was an error, exit with code 1 to
    # stop the whole build.
    sys.exit(1)
else:
    print('All ' + str(total) + ' tests passed.')
        
