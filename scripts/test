#!/usr/bin/python

import optparse, os, subprocess, re, sys, glob

parser = optparse.OptionParser()
parser.add_option('-f', '--full', action='store_true', 
    help='Run all tests, including memcheck')
parser.add_option('-v', '--verbose', action='store_true',  
    help='Print test status')
(options, tests) = parser.parse_args()

os.chdir('tests')

total = 0
fail = False

if len(tests) == 0:
    # If no tests are passed as parameters, then glob on the test dir to run 
    # all the tests.
    tests = glob.glob('*.ap') + glob.glob('*.c') + glob.glob('*.py')

def check(test, expected, output):
    # Checks to make sure the output for the test matches the expected output.
    global fail
    expected = expected.replace('\r', '')
    output = output.replace('\r', '')

    if output != expected:
        print(''.join(['-' for i in range(79)]))
        print('FAILED TEST: ' + test)
        print(''.join(['-' for i in range(70)])+' Expected')
        print(expected)
        print(''.join(['-' for i in range(72)])+' Output')
        print(output)
        fail = True

def shell(command):
    # Runs 'command' and returns the result.  Sets the 'fail' flag if the 
    # command failed.
    proc = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE)
    return proc.stdout.read()

def apollo_test(test):
    # Run a compilation test.  Compile and Apollo source file, and potentially
    # run the resulting program.
    test = re.sub(r'.ap$', '', test)
    flags = ""
    run = False
    for line in open(test + '.ap'):
        if re.search(r'^# aptest print_ast on', line):
            flags += ' --dump-ast'
        elif re.search(r'^# aptest print_ir on', line):
            flags += ' --dump-ir'
        
    if flags == '':
        flags += ' -e'
        run = True
    flags += ' -m -d ../build --optimize'
    command = '../bin/apollo ' + test + ' -i ../runtime -i ../lib ' + flags
    if options.full:
        valgrind = 'valgrind -q --leak-check=full'
        valgrind += ' --suppressions=../scripts/valgrind.supp'
        command = valgrind + ' ' + command
    expected = open(test + '.ap.out', 'rb').read() 
    if sys.platform == 'win32':
        command = command.replace('/', '\\')
    output = shell(command + ' 2>&1')
    check(test, expected, output)
    

def python_test(test):
    # Run a Python test.  Useful for various msicellaneous tests that are not
    # easily expressed in C++.
    expected = open(test + '.out', 'rb').read()
    output = shell('python ' + test + ' 2>&1')
    check(test, expected, output)

def native_test(test):
    # C/C++ tests.  Used primarily for unit tests and to test the runtime
    # library.
    expected = open(test + '.out', 'rb').read()
    exe = re.sub(r'.c$', '', test)
    output = ""
    if sys.platform == 'win32':
        command = 'cl ' + test + ' /Fe..\\build\\' + exe + ' /I:.. apollo.lib '
        command += '/link /NODEFAULTLIB:LIBCMT.lib /LIBPATH:..\\lib 2>&1'
        os.popen(command).read()
        output = shell('..\\build\\' + exe + ' 2>&1')
    else:
        command = 'gcc -g ' + test + ' -o ../build/' + exe + ' -L../lib '
        command += '-lapollo -lm -I .. 2>&1'
        print(os.popen(command).read())
        output += shell('../build/' + exe + ' 2>&1')
    check(test, expected, output)



for test in tests:
    # Iterate through all the tests, and run the correct callback for each
    # test type.
    print(test)
    if re.search(r'.ap$', test):
        apollo_test(test)
        total += 1
    elif re.search(r'.py$', test):
        python_test(test)
        total += 1
    elif re.search(r'.c$', test):
        native_test(test)
        total += 1

if fail:
    # Finally, check for errors.  If there was an error, exit with code 1 to
    # stop the whole build.
    sys.exit(1)
else:
    print('All ' + str(total) + ' tests passed.')
        
